I want to design a game, I would like to do it using library pygame (I have everything setup for this already), I want to start in Pycharm Community edition using: if __name__ == "__main__": main() I want a single python file as output.

Description of game:
PyFrogger: Core Design & Technical Specification
Version: 1.0

1. Core Gameplay Loop
PyFrogger is a real-time action/puzzle game. The player guides a frog from the bottom of the screen to one of several empty "homes" at the top. To do this, the frog must first cross multiple lanes of a busy highway, avoiding moving vehicles. Then, it must cross a treacherous river by hopping on moving logs and turtles. The player has a limited number of lives and a time limit to get each frog home safely.

2. Game Rules & Logic
Player (Frog):

Starts with a set number of lives (e.g., 3).
Moves in discrete "hops" (Up, Down, Left, Right) on a grid.
A time limit (e.g., 30 seconds) is active for each life.
The Highway (Bottom Half):

Comprised of multiple horizontal lanes.
Vehicles (cars, trucks) move horizontally across these lanes at different speeds.
Collision with a vehicle results in the loss of a life.
The River (Top Half):

Comprised of multiple horizontal lanes.
Touching the water is lethal and results in the loss of a life.
Logs and Turtles act as moving platforms. The player must land on these to cross safely.
Platform Logic (CRITICAL): When the frog is on a log or turtle, it moves along with that platform. The frog's global position must be updated with the platform's movement each frame.
Winning & Losing:

Lose a Life if:
The frog is hit by a vehicle.
The frog lands in the water.
The timer runs out.
The frog is carried off-screen by a platform.
Win a Round: Successfully guide the frog into an empty home at the top of the screen. The player resets at the bottom to save the next frog.
Win a Level: Fill all 5 homes. This should lead to a "Level Complete" screen and advance to the next, faster level.
Game Over: Lose all lives.
Scoring:

+10 points for each successful forward hop.
+50 points for successfully guiding a frog home.
Bonus points awarded based on the time remaining on the clock when a frog reaches home.
3. Controls
Movement: Arrow Keys or W, A, S, D (for one hop in the respective direction).
Start / Restart: Enter
Quit Game: Escape
4. Game States & Flow
Main Menu → Gameplay → Level Complete / Game Over

Main Menu: Displays game title and "Press Enter to Start".
Gameplay: The active state. Manages all moving objects, collision detection, the timer, and player input.
Level Complete: Triggered when all 5 homes are filled. Displays score and prompts the player to start the next (harder) level.
Game Over: Triggered when all lives are lost. Displays "GAME OVER," final score, and a prompt to restart from the main menu.
5. UI & Visuals
Aesthetic: Vibrant, colorful, 8-bit retro arcade style.
Layout: The screen is divided into distinct horizontal zones:
Top: Goal Area (5 "homes" or "lily pads" with a grass/dirt background).
Upper: River Area.
Middle: Safe Median (a single row of grass).
Lower: Highway Area.
Bottom: Starting Zone (a single row of grass).
HUD (Bottom of the window):
Lives: Displayed as small frog icons.
Score: "SCORE: [value]"
High Score: "HIGH SCORE: [value]"
Timer: A visual bar that depletes over time is highly recommended for a classic feel.
Sprites: Requires distinct sprites for:
Frog (with different facings: up, down, left, right).
Multiple vehicle types (e.g., car, truck).
Logs (different lengths).
Turtles.
A "frog in home" sprite to show filled goals.
6. Pygame Technical Specifications
Display: A vertically-oriented aspect ratio is classic. A resolution like 800 x 600 or 480 x 560 works well.
Game Loop: This is a real-time game. A standard game loop running at a fixed FPS (e.g., 60) is necessary for smooth animation and responsive controls.
Lane-Based System (CRITICAL):
Model the game world as a series of horizontal "lanes."
Each lane object should have properties like type (road, water, grass), object_speed, and direction (-1 for left, 1 for right).
The Frog's position can be tracked on a logical grid (e.g., (column, row)).
Object Management:
Use pygame.sprite.Group to manage clusters of cars, logs, etc.
Objects that move off one side of the screen should "wrap around" and reappear on the other side to create a continuous flow.
Collision Detection:
Use pygame.Rect.colliderect() for all collision checks.
River Logic: First, check if the frog's y coordinate is in the river zone. If True, then iterate through the safe platform sprites (logs, turtles) to check for a collision. If there's no collision with a safe platform, the frog is in the water.