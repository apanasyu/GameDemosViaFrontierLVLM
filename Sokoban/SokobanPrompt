I want to design a game, I would like to do it using library pygame (I have everything setup for this already), I want to start in Pycharm Community edition using: if __name__ == "__main__": main() I want a single python file as output.

Description of game:
PySoko: Core Design & Technical Specification
Version: 1.0

1. Core Gameplay Loop
PySoko is a tile-based puzzle game. The player controls a character within a maze-like level. The objective is to push all boxes onto designated storage locations. The game is turn-based, focusing on logic and state management rather than speed. A level is complete when all boxes are on their targets.

2. Game Rules & Logic
Game Objects: The game grid consists of the following static and dynamic tiles:

Wall: Impassable.
Floor: Passable.
Storage Location (Goal): A special floor tile. The target for a box.
Player: The user-controlled character.
Box: An object that can be pushed by the player.
Movement & Pushing Logic (The Core Algorithm):

The player attempts to move one tile in a given direction (Up, Down, Left, Right).
Check Target Tile:
If the target tile is a Wall, the move is invalid.
If the target tile is a Floor or Storage Location, the player moves to it.
If the target tile is a Box, check the tile behind the box.
If the tile behind the box is a Wall or another Box, the move is invalid.
If the tile behind the box is a Floor or Storage Location, the box is pushed to that tile, and the player moves into the box's former tile.
Win Condition:

The level is won when every Storage Location tile is occupied by a Box.
Undo Mechanic (Key Feature):

The game must maintain a history of game states.
Implementation: Use a stack. Before each valid player move, push the current state (positions of the player and all boxes) onto the undo stack.
The "Undo" action pops the last state from the stack and restores the player and box positions.
3. Controls
Movement: Arrow Keys or W, A, S, D
Undo Move: Z or U
Restart Level: R
Next Level: N (Available on level complete screen)
Previous Level: P
Quit Game: Escape
4. Game States & Flow
The game operates in a simple loop of Load → Play → Win.

Level Loading: On startup or after a win, the game parses a level file to build the game state.
Gameplay: The main interactive state. The game waits for player input, validates moves, and updates the game state. Tracks move and push counts.
Level Cleared: A state triggered by the win condition.
Freezes gameplay input (except for N, P, R).
Displays a "Level Cleared!" message.
Waits for the player to select the next level or restart.
5. UI & Visuals
Aesthetic: Clean, simple, and functional. Clarity is more important than flashiness.
Graphics: Can be simple colored squares or basic 2D sprites.
Visual States: It is critical to visually distinguish combined states:
Player: A distinct color/sprite (e.g., Yellow).
Wall: A dark, solid color (e.g., Dark Gray #333333).
Floor: A neutral background color (e.g., Light Gray #CCCCCC).
Box: A contrasting color (e.g., Brown #8B4513).
Storage Location: A visually distinct floor tile (e.g., a Blue circle/square #0000FF).
Box on Storage Location: The box sprite/color should change to indicate success (e.g., Green Box #008000).
HUD / On-Screen Info:
Display persistently on screen (e.g., in a top banner or corner).
Level: "Level: 3"
Moves: "Moves: 42"
Pushes: "Pushes: 15"
Controls Hint: "[R] Restart | [Z] Undo"
6. Pygame Technical Specifications
Display:
Window Size: Flexible, e.g., 1024 x 768. The game world should center itself.
Tile Size: 32x32 or 48x48 pixels for a clear, readable grid.
Game Loop:
The game is event-driven (turn-based). The screen only needs to redraw after a valid player input (pygame.event.wait()). It does not need to update every frame at 60 FPS.
Level File Format (Key Feature):
Levels should be loaded from simple .txt files. Define a character map for parsing:
#: Wall
(space): Floor
@: Player
$: Box
.: Storage Location
*: Box on a Storage Location (convenience for level design)
+: Player on a Storage Location (convenience for level design)
Core Data Structures:
Static Map (Walls, Floors, Goals): A 2D list/array holding character codes from the level file.
Dynamic Objects: A list of coordinate tuples for boxes, and a single tuple for the player's position.
Undo Stack: A list acting as a stack, storing tuples of (player_pos, list_of_box_pos).