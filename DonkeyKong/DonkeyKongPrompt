I want to design a game, I would like to do it using library pygame (I have everything setup for this already), I want to start in Pycharm Community edition using: if __name__ == "__main__": main() I want a single python file as output.

Description of game:
PyKong: Core Design & Technical Specification
Version: 1.0

1. Core Gameplay Loop
PyKong is a real-time, single-screen platformer. The player controls "Jumpman," who must navigate a structure of sloped girders and ladders. The goal is to reach the princess at the top of the screen while avoiding barrels thrown by a large ape, "Kong." The game is a test of timing, jumping, and pattern recognition.

2. Game Rules & Logic
Player (Jumpman):

Movement: Can run left and right on girders. Can climb up and down ladders.
Jumping: Can jump vertically or in an arc while running. Used to clear barrels.
Climbing: Player movement is restricted to vertical on ladders. Cannot jump while on a ladder.
Gravity: When not on a ladder, the player is constantly affected by gravity and will fall until landing on a girder.
Kong (The Antagonist):

Stands at the top-left of the screen.
Periodically spawns a Barrel that rolls down the structure. His animation should sync with the spawn.
Barrels (The Hazard):

Follow the slope of the girders.
Have a chance to descend a ladder they pass over.
A collision with a barrel results in the player losing a life.
The Hammer (Power-up):

Two hammers are placed on the level.
Picking one up grants Jumpman temporary invincibility and the ability to destroy barrels for points.
The player is frozen in a "hammering" animation and cannot jump or climb while the power-up is active.
The power-up is on a short timer.
Scoring:

Jump Over Barrel: +100 points.
Destroy Barrel (with Hammer): +300 points.
Level Clear Bonus: Points based on a countdown timer.
Win/Loss Conditions:

Win: Reach the princess at the top of the screen.
Lose a Life:
Make contact with a barrel (unless using the Hammer).
Fall from a height greater than a small, safe threshold.
Game Over: Lose all available lives.
3. Controls
Movement: Arrow Keys or A / D
Climb: Up / Down Arrow Keys or W / S (when overlapping a ladder)
Jump: Space Bar
Start Game: Enter
4. Game States & Flow
Title Screen → Get Ready! → Gameplay 循环 (Player Death → Gameplay) → Level Clear → (Loop to Get Ready!)

Title Screen: Shows game title, high score, and "Press Enter" prompt.
Get Ready!: Brief pause before gameplay starts. Level, player, and enemies are shown in their starting positions.
Gameplay: The main, interactive state. Player is controllable, Kong throws barrels, score updates.
Player Death: A short animation/pause when the player loses a life. Player and barrels reset to starting positions. Decrement life counter. If lives < 0, transition to Game Over.
Level Clear: A short celebratory animation/pause. Award bonus points.
Game Over: Displays "GAME OVER" and final score. Waits for Enter to return to the Title Screen.
5. UI & Visuals
Aesthetic: 8-bit retro arcade style, imitating the original.
Sprites (Essential):
Jumpman: Idle, run cycle (2-3 frames), jump, climb, hammer-wielding, and death animations.
Kong: Idle, barrel-throwing animations.
Princess: "Help!" animation loop.
Barrel: Rolling animation (4 frames), static image for icon.
Hammer: Static item sprite.
Environment: Sprites or tiles for girders and ladders.
HUD (Arcade Style):
Top-Left: Player 1 Score
Top-Center: High Score
Top-Right: Life counter (represented by player head icons), Level number.
Bottom-Right: Bonus points timer.
6. Pygame Technical Specifications
Display:
Window Size: A portrait orientation is authentic. Recommended: 600 x 800 pixels.
Game Loop: Real-time loop is critical. Use pygame.time.Clock to cap the framerate (e.g., 60 FPS) for consistent physics.
Physics & Collision (The Core Challenge):
Gravity: A constant value (e.g., 0.5) added to the player's y_velocity each frame.
Jumping: Set a negative y_velocity (e.g., -12) when the jump key is pressed.
Platforms: Represent girders as a list of pygame.Rect objects. For sloped platforms, Rects can be thin, overlapping horizontal strips to simulate a slope.
Collision Detection:
Use pygame.Rect.colliderect() for all interactions.
Player-Platform: Check for collision. If player is falling (y_velocity > 0) and collides, set their y_velocity to 0 and snap their y position to the top of the platform. This prevents sinking and allows jumping "through" platforms from below.
Player-Ladder: Check for overlap. If overlapping and Up/Down is pressed, switch player state to "climbing."
Player-Barrel: Check for collision to trigger player death.
Level Representation:
Since it's a single screen, hard-code the positions and dimensions of platform/ladder Rect objects into a list or dictionary for easy access.
Animation:
For sprite animations (e.g., running), store frames in a list and cycle the list index based on a timer (pygame.time.get_ticks()) to control animation speed independently of framerate.